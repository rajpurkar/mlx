<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="A blog for machine learning experiments.">
    

    <!--Author-->
    
        <meta name="author" content="Pranav Rajpurkar">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Dialog Systems"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="A blog for machine learning experiments." />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="mlx"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    
        <meta name="twitter:site" content="rajpurkar>" />
    

    
        <link rel="icon" type="image/png" href="/mlx/img/favicon.png">
    

    <!-- Title -->
    
    <title>Dialog Systems - mlx</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/mlx/bower_components/bootstrap/dist/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/mlx/css/style.css">

    <!-- Custom Fonts -->
    <link rel="stylesheet" href="/mlx/bower_components/components-font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/mlx/bower_components/lato-font/css/lato-font.min.css">

    <!-- Google Analytics -->
    
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-106613516-1', 'auto');
        ga('send', 'pageview');

    </script>



</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/mlx/">mlx</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/mlx/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/mlx/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/rajpurkar/mlx">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/mlx/img/bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-md-9">
                <div class="post-heading">
                    <h1>Dialog Systems</h1>
                    
                    <h2 class="post-subheading">
                        Learnings from a few papers
                    </h2>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                            By Pranav Rajpurkar on
                        
                        August 31st 2017
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Gallery -->
            
            <!-- Post Main Content -->
            <div class="col-md-9">
                <p>In this post, I share some thoughts on a few papers on dialog systems.</p>
<h1 id="Why-care-about-dialog-systems"><a href="#Why-care-about-dialog-systems" class="headerlink" title="Why care about dialog systems?"></a>Why care about dialog systems?</h1><p>As speech recognition gets better, we can expect to be having more conversations with our devices. Try asking your phone “what event is next on my calendar”, and you can expect the dialog agent to respond after looking at your calendar. On my iPhone, I can continue the conversation, asking “What’s after that?”, and getting the next chronological event. I can even continue with “What’s before that?”, and get the correct answer!</p>
<p>It’s very impressive for a dialog agent to be able to do this. To be able to answer my first question, the agent has to be able to, among other things, understand my query and execute it on my calendar. For the follow-up questions, it needs to keep track of our conversation to know what ‘that’ refers to, and what ‘after’ and ‘before’ are relative to.</p>
<p>Of course, dialog agents are not constrained to speech interactions (also called <em>spoken dialog</em>): text is a natural medium for conversational agents. On the Facebook Messenger platform for instance, use cases include personalized shopping assistance, curated news stories, and assisted food ordering!</p>
<p>We’ll look at a mix of papers on dialog systems.</p>
<h1 id="Paper-1"><a href="#Paper-1" class="headerlink" title="Paper 1"></a>Paper 1</h1><p>The first paper we’ll take a look at is <em><a href="https://arxiv.org/abs/1511.06931">Evaluating Prerequisite Qualities for Learning End-to-End Dialog Systems (2016)</a></em> by Jesse Dodge, Andreea Gane, Xiang Zhang, Antoine Bordes, Sumit Chopra, Alexander Miller, Arthur Szlam, Jason Weston.</p>
<h2 id="At-a-glance"><a href="#At-a-glance" class="headerlink" title="At a glance"></a>At a glance</h2><p>The authors argue that end-to-end dialog systems “lack pertinent goal-oriented frameworks to validate their performance”. The paper proposes of a suite of four tasks for evaluation of dialog systems: QA, Recommendation, QA + Recommendation, and Reddit Discussion. Here are the four tasks, each with an example user-question and expected sample machine response (italicized).</p>
<ul>
<li><p><strong>Factoid QA (stand-alone questions):</strong><br>“Can you name a film directed by Stuart Ortiz?”<br><em>“Grave Encounters”</em></p>
<ul>
<li>Tests ability to answer factoid questions, unspecific to user.</li>
</ul>
</li>
<li><p><strong>Personalized recommendation:</strong><br>“Pulp Fiction, Schneider’s List, and The Godfather are movies are movies I like. What else will I like?”<br><em>“The Hunt for Red October”</em></p>
<ul>
<li>Tests ability to answer recommendation questions, specific to user.</li>
</ul>
</li>
<li><p><strong>QA + Recommendation Dialog</strong>:<br>“I loved X, Y, and Z. I’m looking for a Fantasy movie.”<br><em>“School of Rock.”</em><br>“What else is that about?<br><em>“Music, J, K, L…”</em><br>“I like rock and roll movies more. Do you know anything else?”<br><em>“Little Richard”</em></p>
<ul>
<li>3 turns between user and system.</li>
<li>Tests ability to use short-term context. To answer the second question, a system would have to solve the coreference for ‘that’.</li>
</ul>
</li>
<li><p><strong>Reddit Discussion</strong>:<br>“I think the Terminator movies really such, I mean the first one was kinda ok, but after that they got really cheesy…””<br><em>“C’mon the second one was still pretty cool… Arny was so badass…”</em></p>
<ul>
<li>Tests ability of a system to pick the most probable replies on reddit discussion comments.</li>
</ul>
</li>
</ul>
<p>In all of the tasks, for each question, the system is given a list of possible answer candidates, and has to rank them from most probable to least probable. If the right answer, or one of the right answers, is high up on the system’s ranking (in the top k, where k is task specific), then the system is considered correct, and wrong otherwise. This is called the hits@k accuracy.</p>
<h2 id="Food-for-thought"><a href="#Food-for-thought" class="headerlink" title="Food for thought"></a>Food for thought</h2><ul>
<li>Evaluation that points to a system’s strengths and weaknesses is informative of how much improvement remains, and where the improvement can come from. It’s not immediately clear how one can evaluate a dialog system: what does it mean for the machine to do well at dialog? The paper distinguishes between goal-oriented dialog, where the success of the dialog is tied to the completion of some task, and <em>chit-chat</em>, tied to having a sensible conversation about some topic.</li>
<li>The paper is motivated by that evaluation relies either on humans (hand-labelling / crowdsourcing) or use machine translation metrics like BLEU: the former is problematic because human-evaluation is costly and time-intensive, and the latter is problematic because such metrics “judge the quality of the generated language only” rather than “assess if end-to-end systems can conduct dialog to achieve pre-defined objectives”. Thus the task in the paper is set up such that a model is supposed to rank answer candidates, rather than generating its own answers. The paper argues that this ranking setup focuses the evaluation on the quality of the response rather than on quality of language generation.</li>
<li>The paper proposes that end-to-end dialog systems should do well on their proposed suite of tasks, “a necessary but not sufficient condition for a fully functional dialog agent”. It thus seems like a good testbed for dialog agents that are supposed to perform a combination of tasks.</li>
<li>Tasks 1, 2 and 4 are 1 turn (user asks and machine responds). These tasks are thus set up for evaluation of single turn interactions. Task 3 is three turns, and thus tests a system’s ability to keep track of (very) short-term context. Dialog agents might need to keep track of longer term context for good performance on many tasks. As an example, consider a bot that’s supposed to help you troubleshoot an error by asking you many questions in turn. Performance on this suite of tasks might not give a very good indication of how a system would do in a scenario where it’s common to have more than three turn interactions.</li>
</ul>
<p>In the next paper, we’ll look at a paper that introduces a large dataset for evaluating multi-turn dialog systems.</p>
<h1 id="Paper-2"><a href="#Paper-2" class="headerlink" title="Paper 2"></a>Paper 2</h1><p>The second paper we’ll look at is <a href="https://arxiv.org/abs/1506.08909">The Ubuntu Dialogue Corpus: A Large Dataset for Research in Unstructured Multi-Turn Dialogue Systems (2016)</a> by Ryan Lowe, Nissan Pow, Iulian Serban, Joelle Pineau.</p>
<h2 id="At-a-glance-1"><a href="#At-a-glance-1" class="headerlink" title="At a glance"></a>At a glance</h2><p>The authors hypothesize that progress in dialog system is bottlenecked “due to the lack of sufficiently large datasets” for multi-turn conversation. The paper proposes to overcome the data bottleneck by providing “a new large corpus for research in multi-turn conversation”. The corpus, called the Ubuntu Dialogue Corpus, consists of chat log interactions from Ubuntu-related chat rooms. Here are a few properties of the dataset:</p>
<ul>
<li>Two-way conversations.<ul>
<li>Extracted using heuristic rules from a multi-participant setting.</li>
</ul>
</li>
<li>Large number of conversations (100k to a million).<ul>
<li>7 million utterances, 100 million words. An utterance is a message in a conversation.</li>
</ul>
</li>
<li>Many conversations with several turns.<ul>
<li>An average of 8 turns, a minimum of 3 turns.</li>
</ul>
</li>
<li>Task-specific domain.<ul>
<li>Rather than chit-chat. </li>
</ul>
</li>
</ul>
<h2 id="Food-for-thought-1"><a href="#Food-for-thought-1" class="headerlink" title="Food for thought"></a>Food for thought</h2><ul>
<li>Unlike Paper 1, which focused on short interactions (max of three), this one is focused on longer interactions, with multiple turns between the conversational agents (minimum of three).</li>
<li>Like Paper 1, this also considers the task of best response selection, where a system is evaluated on its ability to rank candidate responses, rather than generate a response. The paper argues that (i) current systems are “not yet able to generate good results for this task”, thus make hill-climbing on the response generation hard, and (ii) we don’t have a suitable metric for evaluating generated responses with ground truths (BLEU scores are problematic in their penalization of word-reordering and synonymous words, while human evaluation is expensive). Thus, the paper argues that response selection is a useful metric for the time being, and one that “will eventually lead to improvements on the generation task”.</li>
</ul>
<p>In the next paper, we will see adoption of the response generation approach, and see how they solve the aforementioned drawbacks. Hint: human evaluation. We’ll transition from datasets to models, looking at a neural modelling approach for dialog systems.</p>
<h1 id="Paper-3"><a href="#Paper-3" class="headerlink" title="Paper 3"></a>Paper 3</h1><p>The last paper we’ll take a look at is <em><a href="https://arxiv.org/abs/1503.02364">Neural Responding Machine for Short-Text Conversation (2015)</a></em> by Lifeng Shang, Zhengdong Lu, and Hang Li.</p>
<h2 id="At-a-glance-2"><a href="#At-a-glance-2" class="headerlink" title="At a glance"></a>At a glance</h2><p>The paper tackles the problem of Short Text Conversation, which is characterized one round of conversation, with an input from a user and a response from the machine dialog system. The paper proposes that existing retrieval-based methods (which are supposed to rank candidate answers) are unsuitable because they require a pre-existing list of candidates that cover a large space of answers and are not straightforward to tune in style or attitude. The paper also argues that statistical machine translation (SMT) based methods, which treat the response generation as a translation problem, are unsuitable because equally sensible responses are not semantically equivalent as they are usually in the case of translation. Thus to solve the problem, the paper proposes the Neural Responding Machine (NRM), a neural encoder-decoder for this task.</p>
<p>The NRM proposed is the canonical sequence-to-sequence model seen in neural machine translation: the encoder <em>encodes</em> the user post (source) in a vector representation, and then feeds it to the decoder, which generates the response (target), word by word, conditioned on the encoded representation and the previously generated words. The paper also extends this scheme to use an attention mechanism, which (dynamically) weights the input sequence to determine which parts should be used to generate the next word in a response.</p>
<p>The NRM is trained on a Chinese corpus of around 4.4 million pairs of conversations on Weibo, a microblogging service.</p>
<h2 id="Food-for-thought-2"><a href="#Food-for-thought-2" class="headerlink" title="Food for thought"></a>Food for thought</h2><ul>
<li>Like paper 1, this paper focuses on short text conversation, more specifically on 1-turn interactions.</li>
<li>Unlike paper 1 and paper 2, this paper chooses response generation instead of response selection for conversation. For evaluation, human labelers “judge whether a response (generated or retrieved) is appropriate and natural to an input post”. The paper observes that while retrieval-based methods have inconsistent details that render the response unsuitable, NRM models tend to make general responses. In addition, the top-k decoded NRM responses to the same prompt can be very different in flavor.</li>
</ul>
<p>Dialog systems are improving fast, and I’m curious to see all the applications and adoptions that will open up as a consequence in the next few years.</p>

                
                    
    <hr />
    <h3>Comments:</h3>
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>



                
            </div>
            <div class="col-md-3">
                <h2> Also Read </h2>
                <hr>
                
                    <div class="post-preview">
    <a href="/mlx/qa-and-squad/">
        <h1 class="post-title archive">
            The Stanford Question Answering Dataset
        </h1>
    </a>
    <p class="post-meta archive">
        <!-- Date and Author -->
        
            By Pranav Rajpurkar on
        
        April 3rd 2017
    </p>
</div>
                
                    <div class="post-preview">
    <a href="/mlx/chexpert-validate/">
        <h1 class="post-title archive">
            Validating the CheXpert model on your own data in 30 minutes
        </h1>
    </a>
    <p class="post-meta archive">
        <!-- Date and Author -->
        
            By Pranav Rajpurkar, Jeremy Irvin, Matt Lungren, Curt Langlotz, Percy Liang on
        
        July 15th 2019
    </p>
</div>
                
                    <div class="post-preview">
    <a href="/mlx/treatment-effects/">
        <h1 class="post-title archive">
            Treatment Effects with Decision Trees
        </h1>
    </a>
    <p class="post-meta archive">
        <!-- Date and Author -->
        
            By Pranav Rajpurkar on
        
        September 6th 2017
    </p>
</div>
                
                <hr>
                
                    


<a href="/mlx/tags/nlp/">#nlp</a> <a href="/mlx/tags/dialog/">#dialog</a>


                
            </div>
        </div>
    </div>
</article>



    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                        <li>
                            <a href="https://twitter.com/pranavrajpurkar" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    
                        <li>
                            <a href="https://github.com/rajpurkar/mlx" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    
                        <li>
                            <a href="mailto:pranavsr@cs.stanford.edu" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-envelope-o fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    
                </ul>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="/mlx/bower_components/jquery/dist/jquery.min.js"></script>

<!-- Bootstrap -->
<script src="/mlx/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>

<!-- Disqus Comments -->

<script type="text/javascript">
    var disqus_shortname = 'mlx-2';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>


<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script src="/mlx/bower_components/MathJax/MathJax.js?config=TeX-AMS_CHTML"></script>


</body>

</html>